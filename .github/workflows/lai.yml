name: Encrypt & Decrypt script.min.js with LAICrypto

on:
  push:
    paths:
      - 'script.min.js'
      - '.github/workflows/lai.yml'

jobs:
  encrypt_and_verify:
    runs-on: ubuntu-latest

    steps:
      # 1. Checkout the repository so that script.min.js is available
      - name: Check out code
        uses: actions/checkout@v4

      # 2. Set up Python 3.10
      - name: Set up Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      # 3. Install the laicrypto module from PyPI
      - name: Install laicrypto
        run: |
          python -m pip install --upgrade pip
          pip install laicrypto

      # 4. Encrypt script.min.js → ciphertext.json and then decrypt to verify
      - name: Encrypt & Decrypt script.min.js
        run: |
          python - << 'EOF'
          import math
          import json
          import os
          
          # 1) Import from laicrypto
          from laicrypto import keygen, encrypt, decrypt
          
          # 2) LAI parameters (must match what your module expects)
          p = 10007
          a = 5
          P0 = (1, 0)
          
          # 3) Helpers to split file bytes into int blocks < p
          def max_block_size(p: int) -> int:
              bit_len = p.bit_length()
              return (bit_len - 1) // 8
          
          def file_to_int_blocks(filepath: str, p: int) -> list[int]:
              with open(filepath, "rb") as f:
                  raw = f.read()
              B = max_block_size(p)
              if B < 1:
                  raise ValueError("Prime p is too small; block size < 1 byte.")
              blocks = []
              n_blocks = math.ceil(len(raw) / B)
              for i in range(n_blocks):
                  chunk = raw[i*B : (i+1)*B]
                  m_int = int.from_bytes(chunk, byteorder="big")
                  if m_int >= p:
                      raise ValueError(f"Block {i} integer {m_int} ≥ p; increase p or reduce B.")
                  blocks.append(m_int)
              return blocks
          
          # 4) Encrypt all integer blocks of script.min.js
          input_js = "script.min.js"
          if not os.path.exists(input_js):
              raise FileNotFoundError(f"Cannot find {input_js} in the repository root.")
          
          # 4.1) Generate LAI keypair
          private_k, public_Q = keygen(p, a, P0)
          
          # 4.2) Split script.min.js into integer blocks
          m_blocks = file_to_int_blocks(input_js, p)
          
          ciphertext_blocks = []
          for m_int in m_blocks:
              # encrypt now expects six arguments: (m_int, public_Q, private_k, p, a, P0)
              C1, C2, r = encrypt(m_int, public_Q, private_k, p, a, P0)
              ciphertext_blocks.append({
                  "C1": [C1[0], C1[1]],
                  "C2": [C2[0], C2[1]],
                  "r": r
              })
          
          # 4.3) Write ciphertext JSON
          output_json = "ciphertext.json"
          result = {
              "p": p,
              "a": a,
              "P0": [P0[0], P0[1]],
              "k": private_k,
              "Q": [public_Q[0], public_Q[1]],
              "blocks": ciphertext_blocks
          }
          with open(output_json, "w", encoding="utf-8") as fout:
              json.dump(result, fout, indent=2)
          
          print(f"✅ Encryption complete, wrote {output_json}")
          
          # 5) Decrypt “ciphertext.json” back into raw bytes and compare to script.min.js
          with open(output_json, "r", encoding="utf-8") as fin:
              loaded = json.load(fin)
          
          decrypted_int_blocks = []
          for blk in loaded["blocks"]:
              x1, y1 = blk["C1"]
              x2, y2 = blk["C2"]
              r_val = blk["r"]
              # decrypt now expects five arguments: (C1, C2, private_k, r, a, p)
              m_int = decrypt((x1, y1), (x2, y2), loaded["k"], r_val, loaded["a"], loaded["p"])
              decrypted_int_blocks.append(m_int)
          
          # 6) Reassemble bytes from decrypted integer blocks
          B = max_block_size(loaded["p"])
          all_bytes = bytearray()
          for m_int in decrypted_int_blocks:
              if m_int < 0 or m_int >= loaded["p"]:
                  raise ValueError(f"Decrypted integer out of range: {m_int}")
              if m_int == 0:
                  chunk = b"\x00"
              else:
                  byte_len = math.ceil(m_int.bit_length() / 8)
                  chunk = m_int.to_bytes(byte_len, byteorder="big")
              if len(chunk) > B:
                  raise ValueError(f"Block at integer {m_int} has length > B")
              chunk = chunk.rjust(B, b"\x00")
              all_bytes.extend(chunk)
          
          # 7) Read original file
          with open(input_js, "rb") as fin_js:
              original_bytes = fin_js.read()
          
          # Remove any zero‐padding from the last block
          decrypted_bytes = bytes(all_bytes[: len(original_bytes)])
          
          if decrypted_bytes != original_bytes:
              raise RuntimeError("❌ Decryption mismatch: decrypted content != original script.min.js")
          
          print("✅ Decryption successful: plaintext matches script.min.js exactly")
          EOF
